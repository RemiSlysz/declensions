<!--
****               RUSSIAN DECLENSION-O-MATIC                ****
****        Thomas Karpiniec <tk@1.21jiggawatts.net>         ****
****  Retrieve grammar tables from Wiktionary automatically  ****

MIT Licensed:
Copyright (c) 2018 Thomas Karpiniec
Copyright (c) 2013 Ramesh Nair (Levenshtein algorithm)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Changelog:
2018-07-15  First rough version online
2018-07-17  Merge into single MIT-licensed file
            Improve visual appearance
            De-bold the root word and highlight search term in table
            Support ?q=term and #term URL shortcuts
            Cache API calls
-->

<!doctype html>
<html lang="en">
    <head>
        <title>Russian Declension-o-matic</title>
        <meta charset="UTF-8">
        <style type="text/css">
            body {
                font-family: sans-serif;
            }
            .main-body {
                max-width: 60em;
                margin-left: auto;
                margin-right: auto;
                background-color: white;
            }
            #status {
                font-style: italic;
            }
            .search-bar {
                background-color: rgb(112, 149, 218);
                padding: 2em;
            }
            form {
                width: 100%;
                display: flex;
                flex-direction: row;
            }
            #submit {
                width: 150px;
                font-size: 1.5em;
            }
            #search_term {
                flex-grow: 1;
                font-size: 1.5em;
            }
            #results table {
                margin-left: auto;
                margin-right: auto;
            }
            #results td, #results th {
                padding-left: 0.7em;
                padding-right: 0.7em;
                padding-top: 0.2em;
                padding-bottom: 0.2em;
                text-align: center;
            }
            #results td {
                background-color: rgb(247, 250, 255);
            }
            #results th {
                background-color: rgb(226, 233, 255);
            }
            #results td.match {
                background-color: rgb(255, 177, 177);
            }
            #results caption {
                display: none;
            }
            span.Latn {
                font-size: 0.8em; /* transliterations */
            }
        </style>
    </head>

    <body>
    <div class="main-body">
        <h1>Russian Declension-o-matic</h1>
        <p>Enter a Russian word. This tool will try to locate the declensions or conjugations on English Wiktionary. <a href="https://github.com/thombles/declensions">Code &amp; Docs</a></p>
        <div class="search-bar">
            <form onSubmit="return doSearch()">
                <input id="search_term" type="text" placeholder="слово">
                <input id="submit" type="submit" value="Search">
            </form>
        </div>
        <p id="status">No search in progress.</p>
        <div id="results">

        </div>
    </div>

    <!-- Main application script -->
    <script type="text/javascript">
        const ST_INITIAL_SEARCH = "Searching for word: ";
        const ST_DEFINITION = "Loading definition page: ";
        const ST_DONE = "Done.";
        const ST_NOT_FOUND = "Couldn't locate a declension table for that word. :(";
        const ST_ERROR = "Sorry, an error occurred.";
        const TITLE = "Russian Declension-o-matic";

        // Caches that will last for the lifetime of this page
        // This will neatly handle repeated lookups if the user navigates тут и там
        // But any issues can be fixed with a refresh
        var queryId = 0; // maintain consistency across JSONP requests. A bit ugly but it'll work.
        var searchCache = {};
        var pageCache = {};

        var hashCheck = function() {
            var initialTerm = null;
            const queryMatch = window.location.href.match(/\?q=([^#]+)/);
            // Look for ?q=слово
            if (queryMatch) {
                initialTerm = decodeURIComponent(queryMatch[1]);
            }
            // Look for #слово (doesn't hurt to have options)
            if (window.location.hash) {
                initialTerm = decodeURIComponent(window.location.hash.substr(1));
            }
            if (initialTerm) {
                document.getElementById("search_term").value = initialTerm;
                doSearch(true);
            }
        }
        window.onload = hashCheck;
        window.onhashchange = hashCheck;

        // User pressed the Search button. Run a search query against Wiktionary and suppress form submission.
        function doSearch(suppressHistory) {
            clearResults();
            const term = getSearchTerm();
            if (term.length == 0) {
                return false;
            }
            updateStatusText(ST_INITIAL_SEARCH + term);
            updatePageTitle(term);
            if (!suppressHistory) {
                history.pushState(null, null, `#${term}`);
            }

            // Use the cache if possible
            if (searchCache[term]) {
                handleSearchResults(searchCache[term], term);
                return false;
            }
            
            // Make a handler for this query
            const queryHandler = `handleSearchResults${++queryId}`;
            window[queryHandler] = function(json) {
                handleSearchResults(json, term);
            }

            runWiktionaryApi(makeSearchApiUrl(term, queryHandler));
            return false;
        }

        function handleSearchResults(json, term) {
            // See if we got a page. Not watertight but it'll do.
            if (!json.query || !json.query.search ) {
                error();
                return;
            }

            // We seem to have a result so save it for later
            searchCache[term] = json;

            // Filter out any that have spaces in them. Multi-word phrases can mess up our results.
            const results = json.query.search.filter(function(r) {
                return r.title.indexOf(" ") == -1;
            });

            if (results.length == 0) {
                updateStatusText(ST_DONE);
                showSearchResultLink(getSearchTerm());
                return;
            }

            // Out of those left, which index matches our search term most closely?
            // For this application we want the title that is most similar to our search term, out of the top 10 results
            // Root words are usually pretty similar to their declensions so this should help
            var bestResult = 0;
            var bestDistance = 1000;
            for (let i = 0; i < results.length; i++) {
                const possibleTitle = results[i].title;
                const distance = Levenshtein.get(getSearchTerm(), possibleTitle);
                if (distance < bestDistance) {
                    bestResult = i;
                    bestDistance = distance;
                }
            }

            // Use the top result out of whatever are left
            const title = results[bestResult].title;
            requestDefinitionPage(title);
        }

        // We have the content of the definition page
        // This _might_ contain the table we want directly.
        // Often it's a short linker page "1. genitive singular of сло́во"
        // In this case we want to follow that link.
        function handleDefinitionPage(json, term) {
            if (!json || !json.parse || !json.parse.text) {
                error();
                return;
            }

            // We have a result so let's cache it
            pageCache[term] = json;

            const text = json.parse.text["*"];
            
            // Invoke Zalgo. The <center> cannot hold
            // Step 1: Get an array of offsets after which we should find a promising <table>...</table>
            var matchingTableIndices = [];
            var startIndex = 0;
            while (true) {
                var declIndex = text.indexOf('Declension of <b lang="ru" class="Cyrl">', startIndex+1);
                var conjIndex = text.indexOf('Conjugation of <span lang="ru" class="Cyrl">', startIndex+1);
                const bigNum = 100000000;
                if (declIndex == -1) declIndex = bigNum;
                if (conjIndex == -1) conjIndex = bigNum;
                if (declIndex < conjIndex) {
                    startIndex = declIndex;
                } else if (conjIndex < declIndex) {
                    startIndex = conjIndex;
                } else {
                    break;
                }
                matchingTableIndices.push(startIndex);
            };
            
            // Step 2: Extract the HTML of the corresponding tables
            var matchingTables = [];
            for (var i = 0; i < matchingTableIndices.length; i++) {
                const index = matchingTableIndices[i];
                const remainder = text.substring(index);
                const tableStart = remainder.indexOf("<table");
                const tableEnd = remainder.indexOf("</table>");
                const tableHtml = remainder.substring(tableStart, tableEnd + 8);
                // The right table will actually contain our word
                const normalisedTable = normaliseRussian(tableHtml);
                const normalisedTerm = normaliseRussian(term);
                if (normalisedTable.indexOf(normalisedTerm) != -1) {
                    matchingTables.push(tableHtml);
                }
            }

            if (matchingTables.length > 0) {
                // Plan A: We have a declension table right here
                showDeclensionTable(json.parse.title, matchingTables[0]);
                updateStatusText(ST_DONE);
            } else {
                // Plan B: Is this a form of a root word that is documented in another page?
                // Sometimes there are multiple... often they're different declensions the same root word
                // Just take the first one
                const redirects = text.match(/<span class="form-of-definition-link"><i class="Cyrl mention" lang="ru"><a href="\/wiki\/([^#]+)/);
                if (redirects && redirects.length > 0) {
                    requestDefinitionPage(redirects[1]);
                } else {
                    // We have actually failed
                    updateStatusText(ST_NOT_FOUND);
                }
            }
        }

        function requestDefinitionPage(title) {
            title = decodeURIComponent(title);

            // Use cache if possible
            if (pageCache[title]) {
                handleDefinitionPage(pageCache[title], title);
                return;
            }

            // Make a function to catch this specific query
            const queryHandler = `handleDefinitionPage${++queryId}`;
            window[queryHandler] = function(json) {
                handleDefinitionPage(json, title);
            }

            const url = makeGetPageUrl(title, queryHandler);
            updateStatusText(ST_DEFINITION + " " + title);
            runWiktionaryApi(url);
        }

        // We found the declensions table we're looking for. Take the HTML and show it to the user.
        function showDeclensionTable(title, html) {
            html = cleanUpRawTable(html);

            // Put it on the page
            const r = document.getElementById("results");
            r.innerHTML = `<p>Wiktionary page: <b><a href="https://en.wiktionary.org/wiki/${title}#Russian">${title}</a></b></p>\n`;
            r.innerHTML += html;

            highlightSearchTerm();
        }

        // If we fail provide a link to the raw search results
        function showSearchResultLink(term) {
            document.getElementById("results").innerHTML = 
                `No declension table found: <a href="https://en.wiktionary.org/w/index.php?search=${term}">Wiktionary search</a>`;
        }
        
        // Eliminate symbols and links and things that we don't want from the retrieved table
        function cleanUpRawTable(html) {
            // Strip all links
            html = html.replace(/<a[^>]*>/g, "");
            html = html.replace(/<\/a[^>]*>/g, "");
            // Strip marker symbols
            html = html.replace(/△/g, "");
            // Remove the strong elements marking the root word
            html = html.replace(/<strong[^>]*>/g, "");
            html = html.replace(/<\/strong[^>]*>/g, "");
            // Replace the min-width specification on the table with centering
            html = html.replace(/width:100%/g, "");
            html = html.replace(/min-width:\d+em/g, "");
            // Eliminate background colours so we can make them consistent with CSS
            html = html.replace(/background:[^";]+/g, "");
            html = html.replace(/background-color:[^";]+/g, "");
            return html;
        }

        // Try to find and highlight the term we searched for, ignoring emphasis accents
        function highlightSearchTerm() {
            const ruSpans = document.getElementsByClassName("Cyrl");
            // Double dots are often omitted on Russian "ё" so treat it the same as "е"
            const term = normaliseRussian(getSearchTerm());
            for (var i = 0; i < ruSpans.length; i++) {
                const s = ruSpans[i];
                const content = normaliseRussian(s.innerText);
                if (content == term) {
                    s.parentElement.classList.add("match");
                }
            }
        }

        function normaliseRussian(word) {
            return word.trim().replace("ё", "е").normalize('NFD').replace(/\u0301/g, "");
        }

        function getSearchTerm() {
            return document.getElementById("search_term").value;
        }

        function updateStatusText(text) {
            document.getElementById("status").innerText = text;
        }

        function updatePageTitle(text) {
            document.title = `${text} - ${TITLE}`;
        }

        function makeSearchApiUrl(term, callback) {
            return `https://en.wiktionary.org/w/api.php?action=query&list=search&srsearch=${term}&srlimit=10&callback=${callback}&format=json`;
        }

        function makeGetPageUrl(title, callback) {
            return `https://en.wiktionary.org/w/api.php?action=parse&page=${title}&format=json&callback=${callback}`;
        }

        // Provided url should already have JSONP callback param set appropriately
        // Avoiding CORS because it is a pain. I want this to work for a locally stored HTML file.
        // Useful ref: https://www.mediawiki.org/wiki/API:Cross-site_requests
        function runWiktionaryApi(url) {
            var script = document.createElement("script");
            script.src = url;
            document.head.appendChild(script);
        }

        function error() {
            updateStatusText(ST_ERROR);
        }

        function clearResults() {
            document.getElementById("results").innerHTML = "";
        }
    </script>

    <!-- Fast Levenshtein by Ramesh Nair, included under MIT licence: https://github.com/hiddentao/fast-levenshtein/ -->
    <script type="text/javascript">
        (function() {
            'use strict';
            
            var collator;
            try {
            collator = (typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined") ? Intl.Collator("generic", { sensitivity: "base" }) : null;
            } catch (err){
            console.log("Collator could not be initialized and wouldn't be used");
            }
            // arrays to re-use
            var prevRow = [],
            str2Char = [];
            
            /**
             * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.
             */
            var Levenshtein = {
            /**
             * Calculate levenshtein distance of the two strings.
             *
             * @param str1 String the first string.
             * @param str2 String the second string.
             * @param [options] Additional options.
             * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.
             * @return Integer the levenshtein distance (0 and above).
             */
            get: function(str1, str2, options) {
                var useCollator = (options && collator && options.useCollator);
                
                var str1Len = str1.length,
                str2Len = str2.length;
                
                // base cases
                if (str1Len === 0) return str2Len;
                if (str2Len === 0) return str1Len;
        
                // two rows
                var curCol, nextCol, i, j, tmp;
        
                // initialise previous row
                for (i=0; i<str2Len; ++i) {
                prevRow[i] = i;
                str2Char[i] = str2.charCodeAt(i);
                }
                prevRow[str2Len] = str2Len;
        
                var strCmp;
                if (useCollator) {
                // calculate current row distance from previous row using collator
                for (i = 0; i < str1Len; ++i) {
                    nextCol = i + 1;
        
                    for (j = 0; j < str2Len; ++j) {
                    curCol = nextCol;
        
                    // substution
                    strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));
        
                    nextCol = prevRow[j] + (strCmp ? 0 : 1);
        
                    // insertion
                    tmp = curCol + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
                    // deletion
                    tmp = prevRow[j + 1] + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
        
                    // copy current col value into previous (in preparation for next iteration)
                    prevRow[j] = curCol;
                    }
        
                    // copy last col value into previous (in preparation for next iteration)
                    prevRow[j] = nextCol;
                }
                }
                else {
                // calculate current row distance from previous row without collator
                for (i = 0; i < str1Len; ++i) {
                    nextCol = i + 1;
        
                    for (j = 0; j < str2Len; ++j) {
                    curCol = nextCol;
        
                    // substution
                    strCmp = str1.charCodeAt(i) === str2Char[j];
        
                    nextCol = prevRow[j] + (strCmp ? 0 : 1);
        
                    // insertion
                    tmp = curCol + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
                    // deletion
                    tmp = prevRow[j + 1] + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
        
                    // copy current col value into previous (in preparation for next iteration)
                    prevRow[j] = curCol;
                    }
        
                    // copy last col value into previous (in preparation for next iteration)
                    prevRow[j] = nextCol;
                }
                }
                return nextCol;
            }
        
            };
        
            // amd
            if (typeof define !== "undefined" && define !== null && define.amd) {
            define(function() {
                return Levenshtein;
            });
            }
            // commonjs
            else if (typeof module !== "undefined" && module !== null && typeof exports !== "undefined" && module.exports === exports) {
            module.exports = Levenshtein;
            }
            // web worker
            else if (typeof self !== "undefined" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {
            self.Levenshtein = Levenshtein;
            }
            // browser main thread
            else if (typeof window !== "undefined" && window !== null) {
            window.Levenshtein = Levenshtein;
            }
        }());
    </script>

    </body>
</html>
