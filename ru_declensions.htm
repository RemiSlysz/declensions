<!--
****               RUSSIAN DECLENSION-O-MATIC                ****
****        Thomas Karpiniec <tk@1.21jiggawatts.net>         ****
****  Retrieve grammar tables from Wiktionary automatically  ****

MIT Licensed:
Copyright (c) 2018 Thomas Karpiniec
Copyright (c) 2013 Ramesh Nair (Levenshtein algorithm)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Changelog:
2018-07-15  First rough version online
2018-07-17  Merge into single MIT-licensed file
            Improve visual appearance
            De-bold the root word and highlight search term in table
            Support ?q=term and #term URL shortcuts
            Cache API calls
            Ensure only a table containing term can match
            Support for back/forward navigation between searches
2018-07-18  Make the all-important pronouns table work
            Make form-of link following more flexible
2018-07-25  Use localeCompare() for case-insensitive Russian comparison
            Parse the HTML as a tree - mostly remove Zalgo
            Always prefer earlier definitions over later ones
-->

<!doctype html>
<html lang="en">
    <head>
        <title>Russian Declension-o-matic</title>
        <meta charset="UTF-8">
        <style type="text/css">
            body {
                font-family: sans-serif;
            }
            .main-body {
                max-width: 60em;
                margin-left: auto;
                margin-right: auto;
                background-color: white;
            }
            #status {
                font-style: italic;
            }
            .search-bar {
                background-color: rgb(112, 149, 218);
                padding: 2em;
            }
            form {
                width: 100%;
                display: flex;
                flex-direction: row;
            }
            #submit {
                width: 150px;
                font-size: 1.5em;
            }
            #search_term {
                flex-grow: 1;
                font-size: 1.5em;
            }
            #results table {
                margin-left: auto;
                margin-right: auto;
            }
            #results td, #results th {
                padding-left: 0.7em;
                padding-right: 0.7em;
                padding-top: 0.2em;
                padding-bottom: 0.2em;
                text-align: center;
            }
            #results td {
                background-color: rgb(247, 250, 255);
            }
            #results th {
                background-color: rgb(226, 233, 255);
            }
            #results td.match {
                background-color: rgb(255, 177, 177);
            }
            #results caption {
                display: none;
            }
            span.Latn {
                font-size: 0.8em; /* transliterations */
            }
        </style>
    </head>

    <body>
    <div class="main-body">
        <h1>Russian Declension-o-matic</h1>
        <p>Enter a Russian word. This tool will try to locate the declensions or conjugations on English Wiktionary. <a href="https://github.com/thombles/declensions">Code &amp; Docs</a></p>
        <div class="search-bar">
            <form onSubmit="return doSearch()">
                <input id="search_term" type="text" placeholder="слово">
                <input id="submit" type="submit" value="Search">
            </form>
        </div>
        <p id="status">No search in progress.</p>
        <div id="results">

        </div>
    </div>

    <!-- Main application script -->
    <script type="text/javascript">
        const ST_INITIAL_SEARCH = "Searching for word: ";
        const ST_DEFINITION = "Loading definition page: ";
        const ST_DONE = "Done.";
        const ST_NOT_FOUND = "Couldn't locate a declension table for that word. :(";
        const ST_ERROR = "Sorry, an error occurred.";
        const TITLE = "Russian Declension-o-matic";

        // Caches that will last for the lifetime of this page
        // This will neatly handle repeated lookups if the user navigates тут и там
        // But any issues can be fixed with a refresh
        var queryId = 0; // maintain consistency across JSONP requests. A bit ugly but it'll work.
        var searchCache = {};
        var pageCache = {};

        const hashCheck = function() {
            var initialTerm = null;
            const queryMatch = window.location.href.match(/\?q=([^#]+)/);
            // Look for ?q=слово
            if (queryMatch) {
                initialTerm = decodeURIComponent(queryMatch[1]);
            }
            // Look for #слово (preferred usage, takes priority)
            if (window.location.hash) {
                initialTerm = decodeURIComponent(window.location.hash.substr(1));
            }
            if (initialTerm) {
                document.getElementById("search_term").value = initialTerm;
                doSearch(true);
            }
        }
        window.onload = hashCheck;
        window.onhashchange = hashCheck;

        // User pressed the Search button. Run a search query against Wiktionary and suppress form submission.
        function doSearch(suppressHistory) {
            clearResults();
            const term = getSearchTerm();
            if (term.length == 0) {
                return false;
            }
            updateStatusText(ST_INITIAL_SEARCH + term);
            updatePageTitle(term);
            if (!suppressHistory) {
                history.pushState(null, null, `#${term}`);
            }

            // Use the cache if possible
            if (searchCache[term]) {
                handleSearchResults(searchCache[term], term);
                return false;
            }
            
            // Make a handler for this query
            const queryHandler = `handleSearchResults${++queryId}`;
            window[queryHandler] = function(json) {
                handleSearchResults(json, term);
            }

            runWiktionaryApi(makeSearchApiUrl(term, queryHandler));
            return false;
        }

        function handleSearchResults(json, term) {
            // See if we got a page. Not watertight but it'll do.
            if (!json.query || !json.query.search ) {
                error();
                return;
            }

            // We seem to have a result so save it for later
            searchCache[term] = json;

            // Filter out any that have spaces in them. Multi-word phrases can mess up our results.
            const results = json.query.search.filter(function(r) {
                return r.title.indexOf(" ") == -1;
            });

            if (results.length == 0) {
                updateStatusText(ST_DONE);
                showSearchResultLink(getSearchTerm());
                return;
            }

            // Out of those left, which index matches our search term most closely?
            // For this application we want the title that is most similar to our search term, out of the top 10 results
            // Root words are usually pretty similar to their declensions so this should help
            var bestResult = 0;
            var bestDistance = 1000;
            for (let i = 0; i < results.length; i++) {
                const possibleTitle = results[i].title;
                const distance = Levenshtein.get(getSearchTerm(), possibleTitle);
                if (distance < bestDistance) {
                    bestResult = i;
                    bestDistance = distance;
                }
            }

            // Use the top result out of whatever are left
            const title = results[bestResult].title;
            requestDefinitionPage(title);
        }

        // We have the content of the definition page
        // This _might_ contain the table we want directly.
        // Often it's a short linker page "1. genitive singular of сло́во"
        // In this case we want to follow that link.
        function handleDefinitionPage(json, term) {
            if (!json || !json.parse || !json.parse.text) {
                error();
                return;
            }

            // We have a result so let's cache it
            pageCache[term] = json;

            const text = json.parse.text["*"];
            const title = json.parse.title;
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, "text/html");
            if (!doc) {
                console.log("Could not parse returned HTML");
                error();
            }
            
            // Find the "Russian" <h2>
            const headlines = doc.getElementsByClassName("mw-headline");
            var currentElement = null;
            for (let i = 0; i < headlines.length; i++) {
                if (headlines[i].innerText.trim() == "Russian") {
                    currentElement = headlines[i].parentElement;
                }
            }
            if (!currentElement || currentElement.tagName != "H2") {
                console.log("Could not find initial <h2>");
                error();
                return;
            }
            
            // Walk along all its siblings and their children until we find another <h2> or run out of siblings
            var foundAction = false;
            while (!foundAction) {
                currentElement = currentElement.nextElementSibling;
                if (!currentElement || currentElement.tagName == "h2") {
                    break;
                }
                foundAction = recursiveSearch(currentElement, title, searchSingleElement);
            }

            if (!foundAction) {
                console.log("Failed to find an action in the Russian section");
                updateStatusText(ST_NOT_FOUND);
            }
        }

        // Generalised recursive node search
        function recursiveSearch(top, title, task) {
            if (task(top, title)) {
                return true;
            }
            for (let i = 0; i < top.childNodes.length; i++) {
                if (recursiveSearch(top.childNodes[i], title, task)) {
                    return true;
                }
            }
            return false;
        }

        // Poke around in a single element to see if it has anything interesting - a link to follow, or a matching table
        function searchSingleElement(el, title) {
            return checkFormOfLinkType1(el) ||
                checkFormOfLinkType2(el) ||
                checkInflectionTable(el, title);
        }

        // <span class="form-of-definition-link">
        // e.g. словам
        function checkFormOfLinkType1(el) {;
            if (el.tagName == "SPAN" && el.classList.contains("form-of-definition-link")) {
                // The <a> should be inside somewhere
                var titleToFollow = null;
                recursiveSearch(el, null, (el) => {
                    if (el.tagName == "A") {
                        const match = el.href.match(/\/wiki\/([^#]+)/);
                        if (match) {
                            titleToFollow = decodeURIComponent(match[1]);
                        }
                    }
                });
                if (titleToFollow) {
                    requestDefinitionPage(titleToFollow);
                    return true;
                }
            }
            return false;
        }

        // form of.*?<span class="Cyrl" lang="ru"
        // e.g. всё
        function checkFormOfLinkType2(el) {
            if (!el.innerText) return false;
            const needle = "form of";
            const haystack = el.innerText.trim();
            const index = haystack.indexOf(needle);
            if ((index != -1) && (index == haystack.length - needle.length) && el.nextElementSibling) { // i.e. endsWith()
                // Try to find an <a> in the next sibling
                var titleToFollow = null;
                recursiveSearch(el.nextElementSibling, null, (el) => {
                    if (el.tagName == "A") {
                        const match = el.href.match(/\/wiki\/([^#]+)/);
                        if (match) {
                            titleToFollow = decodeURIComponent(match[1]);
                        }
                    }
                });
                if (titleToFollow) {
                    requestDefinitionPage(titleToFollow);
                    return true;
                }
            }
            return false;
        }

        // <table class="inflection-table">
        // e.g. слово
        function checkInflectionTable(el, title) {
            // Happily all the declension/conjugation tables seem to have the class "inflection-table"
            // If we find such a table and it contains a span matching our search term, display this table
            // More relevant ones seem to be higher in the wiktionary article so rely on that for now
            if (el.tagName == "TABLE" && el.classList.contains("inflection-table")) {
                var tableMatchesSearch = false;
                const term = getSearchTerm();
                recursiveSearch(el, null, (el) => {
                    if (el.tagName == "SPAN" && compareRussian(el.innerText, term)) {
                        tableMatchesSearch = true;
                    }
                });
                if (tableMatchesSearch) {
                    showDeclensionTable(title, el.outerHTML);
                    return true;
                }
            }
            return false;
        }

        function requestDefinitionPage(title) {
            title = decodeURIComponent(title);

            // Use cache if possible
            if (pageCache[title]) {
                handleDefinitionPage(pageCache[title], title);
                return;
            }

            // Make a function to catch this specific query
            const queryHandler = `handleDefinitionPage${++queryId}`;
            window[queryHandler] = function(json) {
                handleDefinitionPage(json, title);
            }

            const url = makeGetPageUrl(title, queryHandler);
            updateStatusText(ST_DEFINITION + " " + title);
            runWiktionaryApi(url);
        }

        // We found the declensions table we're looking for. Take the HTML and show it to the user.
        function showDeclensionTable(title, html) {
            html = cleanUpRawTable(html);

            // Put it on the page
            const r = document.getElementById("results");
            r.innerHTML = `<p>Wiktionary page: <b><a href="https://en.wiktionary.org/wiki/${title}#Russian">${title}</a></b></p>\n`;
            r.innerHTML += html;

            highlightSearchTerm();
            updateStatusText(ST_DONE);
        }

        // If we fail provide a link to the raw search results
        function showSearchResultLink(term) {
            document.getElementById("results").innerHTML = 
                `No declension table found: <a href="https://en.wiktionary.org/w/index.php?search=${term}">Wiktionary search</a>`;
        }
        
        // Eliminate symbols and links and things that we don't want from the retrieved table
        // Minor Zalgo here but honestly this would be super fiddly using the DOM
        function cleanUpRawTable(html) {
            // Strip all links
            html = html.replace(/<a[^>]*>/g, "");
            html = html.replace(/<\/a[^>]*>/g, "");
            // Strip marker symbols
            html = html.replace(/△/g, "");
            // Remove the strong elements marking the root word
            html = html.replace(/<strong[^>]*>/g, "");
            html = html.replace(/<\/strong[^>]*>/g, "");
            // Replace the min-width specification on the table with centering
            html = html.replace(/width:100%/g, "");
            html = html.replace(/min-width:\d+em/g, "");
            // Eliminate background colours so we can make them consistent with CSS
            html = html.replace(/background:[^";]+/g, "");
            html = html.replace(/background-color:[^";]+/g, "");
            return html;
        }

        // Try to find and highlight the term we searched for
        function highlightSearchTerm() {
            const ruSpans = document.getElementsByClassName("Cyrl");
            const term = getSearchTerm();
            for (let i = 0; i < ruSpans.length; i++) {
                const s = ruSpans[i];
                if (compareRussian(s.innerText, term)) {
                    s.parentElement.classList.add("match");
                }
            }
        }

        // Return true if the two words are the same
        // - trim and case-insensitive
        // - ignore accents on letters e.g. каза́лось
        // - insensitive to ё vs е
        function compareRussian(word1, word2) {
            word1 = word1.trim();
            word2 = word2.trim();
            return word1.localeCompare(word2, "ru", {"sensitivity": "base"}) == 0;
        }

        // Get what the user actually typed
        function getSearchTerm() {
            return document.getElementById("search_term").value.trim();
        }

        function updateStatusText(text) {
            document.getElementById("status").innerText = text;
        }

        function updatePageTitle(text) {
            document.title = `${text} - ${TITLE}`;
        }

        function makeSearchApiUrl(term, callback) {
            return `https://en.wiktionary.org/w/api.php?action=query&list=search&srsearch=${term}&srlimit=10&callback=${callback}&format=json`;
        }

        function makeGetPageUrl(title, callback) {
            return `https://en.wiktionary.org/w/api.php?action=parse&page=${title}&format=json&callback=${callback}`;
        }

        // Provided url should already have JSONP callback param set appropriately
        // Avoiding CORS because it is a pain. I want this to work for a locally stored HTML file.
        // Useful ref: https://www.mediawiki.org/wiki/API:Cross-site_requests
        function runWiktionaryApi(url) {
            var script = document.createElement("script");
            script.src = url;
            document.head.appendChild(script);
        }

        function error() {
            updateStatusText(ST_ERROR);
        }

        function clearResults() {
            document.getElementById("results").innerHTML = "";
        }
    </script>

    <!-- Fast Levenshtein by Ramesh Nair, included under MIT licence: https://github.com/hiddentao/fast-levenshtein/ -->
    <script type="text/javascript">
        (function() {
            'use strict';
            
            var collator;
            try {
            collator = (typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined") ? Intl.Collator("generic", { sensitivity: "base" }) : null;
            } catch (err){
            console.log("Collator could not be initialized and wouldn't be used");
            }
            // arrays to re-use
            var prevRow = [],
            str2Char = [];
            
            /**
             * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.
             */
            var Levenshtein = {
            /**
             * Calculate levenshtein distance of the two strings.
             *
             * @param str1 String the first string.
             * @param str2 String the second string.
             * @param [options] Additional options.
             * @param [options.useCollator] Use `Intl.Collator` for locale-sensitive string comparison.
             * @return Integer the levenshtein distance (0 and above).
             */
            get: function(str1, str2, options) {
                var useCollator = (options && collator && options.useCollator);
                
                var str1Len = str1.length,
                str2Len = str2.length;
                
                // base cases
                if (str1Len === 0) return str2Len;
                if (str2Len === 0) return str1Len;
        
                // two rows
                var curCol, nextCol, i, j, tmp;
        
                // initialise previous row
                for (i=0; i<str2Len; ++i) {
                prevRow[i] = i;
                str2Char[i] = str2.charCodeAt(i);
                }
                prevRow[str2Len] = str2Len;
        
                var strCmp;
                if (useCollator) {
                // calculate current row distance from previous row using collator
                for (i = 0; i < str1Len; ++i) {
                    nextCol = i + 1;
        
                    for (j = 0; j < str2Len; ++j) {
                    curCol = nextCol;
        
                    // substution
                    strCmp = 0 === collator.compare(str1.charAt(i), String.fromCharCode(str2Char[j]));
        
                    nextCol = prevRow[j] + (strCmp ? 0 : 1);
        
                    // insertion
                    tmp = curCol + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
                    // deletion
                    tmp = prevRow[j + 1] + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
        
                    // copy current col value into previous (in preparation for next iteration)
                    prevRow[j] = curCol;
                    }
        
                    // copy last col value into previous (in preparation for next iteration)
                    prevRow[j] = nextCol;
                }
                }
                else {
                // calculate current row distance from previous row without collator
                for (i = 0; i < str1Len; ++i) {
                    nextCol = i + 1;
        
                    for (j = 0; j < str2Len; ++j) {
                    curCol = nextCol;
        
                    // substution
                    strCmp = str1.charCodeAt(i) === str2Char[j];
        
                    nextCol = prevRow[j] + (strCmp ? 0 : 1);
        
                    // insertion
                    tmp = curCol + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
                    // deletion
                    tmp = prevRow[j + 1] + 1;
                    if (nextCol > tmp) {
                        nextCol = tmp;
                    }
        
                    // copy current col value into previous (in preparation for next iteration)
                    prevRow[j] = curCol;
                    }
        
                    // copy last col value into previous (in preparation for next iteration)
                    prevRow[j] = nextCol;
                }
                }
                return nextCol;
            }
        
            };
        
            // amd
            if (typeof define !== "undefined" && define !== null && define.amd) {
            define(function() {
                return Levenshtein;
            });
            }
            // commonjs
            else if (typeof module !== "undefined" && module !== null && typeof exports !== "undefined" && module.exports === exports) {
            module.exports = Levenshtein;
            }
            // web worker
            else if (typeof self !== "undefined" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {
            self.Levenshtein = Levenshtein;
            }
            // browser main thread
            else if (typeof window !== "undefined" && window !== null) {
            window.Levenshtein = Levenshtein;
            }
        }());
    </script>

    </body>
</html>
